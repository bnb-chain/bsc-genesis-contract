pragma solidity ^0.5.0;
import { System } from "./System.sol";

contract SlashIndicator is System{
    uint256 public constant TOLERATEDISTANCE = 1000;
    uint256 public constant SPRINT = 100;
    uint256 public constant OUTTURNDIF = 1;

    event NewValidatorSlash(address indexed validator);


    struct Indicator {
        uint256 height;
        uint256 count;
        bool exist;
    }

    mapping(address => Indicator) indicators;
    uint256 public previousHeight;

    modifier onlyOutTurnBlock() {
        require(block.difficulty == OUTTURNDIF, "the block is not generated by out turn validator");
        _;
    }

    modifier onlyOnce() {
        require(block.number > previousHeight, "can not slash twice in one block");
        _;
        previousHeight = block.number;
    }

    /**
     * @dev Increase the count of the according indicator.
     */
    function slash(address validator) external onlySystem onlyOnce onlyOutTurnBlock{
        Indicator memory indicator = indicators[validator];
        if (indicator.exist){
            if (block.number-indicator.height < TOLERATEDISTANCE){
                indicator.count++;
                if (indicator.count % SPRINT == 0){
                    emit NewValidatorSlash(validator);
                }
            }
        }else{
            indicator.exist = true;
        }
        indicator.height=block.number;
        indicators[validator] = indicator;
    }

    function getSlashIndicator(address validator) view returns (uint256,uint256){
        Indicator memory indicator = indicators[validator];
        return (indicator.height, indicator.count);
    }
}